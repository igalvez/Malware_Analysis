import os
import subprocess
import pefile
import peutils
import winnt
import shutil
from libPDF import LibPDF

pastaRelatorio = 'C:\\Analise\\Relatorios\\'
pastaFerramentas = 'C:\\Analise\\Ferramentas\\'
pastaGT2 = 'C:\\Analise\\Ferramentas\\gt035a\\'
pastaLinux = 'C:\\Analise\\ResumoDinamica\\'

class ClassArtefato:
	#artefato:
	#nome 
	#hash 
	#tipo 
	#bib_e1 
	#compactacao
    #metadata
	#arquivos_Criados 
	#arquivos_Modificados
	#arquivos_Apagados 
	#taskes 
	#registro 
	#bib_d1 
	
	def __init__(self,artefato, nome):
		self.nome = nome
		self.artefato = artefato
		self.hash = None
		self.pid = None
		self.metadata = []
		self.tipo = None
		self.bib_e1 = []
		self.compactacao = None
		self.arquivos_Criados = []
		self.arquivos_Modificados = []
		self.arquivos_Apagados  = []
		self.taskes = {}
		self.registro = []
		self.bib_d1 = []
		
	def calculaHash(self):
		# 1 - Calcula Hash
		nhash = subprocess.Popen('md5sum \"' + self.artefato + '\" | cut -d\" \" -f1', shell=True, stdout=subprocess.PIPE)
		nhash = nhash.stdout.read().strip('\\')
		self.hash = nhash
	
	def defineTipo(self):
		self.tipo = subprocess.Popen('file \"' + self.artefato + '\" | cut -d\";\" -f2', shell=True, stdout=subprocess.PIPE).stdout.read()
		
	def analiseEstaticaBib(self):
		# Usa programa DUMPBIN para listar bibliotecas dinamicas
		bib = []
		aux = []
		try:
			aux = subprocess.Popen('DUMPBIN /DEPENDENTS \"' + self.artefato + '\"', shell=True, stdout=subprocess.PIPE).stdout.readlines()
		except:
			print '\n ERRO\n'
		for i in aux:
			if 'File Type' in i:
				tipo1 = i
			else:
				if 'dll' in i:
					bib.append(i.strip('\n\r'))
		
		#descarta, tipo = tipo1.split(':')
		#self.tipo = tipo
		self.bib_e1 = sorted(set(bib))
	
	def analiseMetadata(self):
		print '\n artefato: ' + self.artefato + '\n'
		print '\n nome: ' + self.nome + '\n'
		aux = subprocess.Popen(pastaGT2 + 'gt2 ' + self.artefato, shell=True, stdout=subprocess.PIPE).stdout.readlines()
		cont = 0
		for i in aux:
			print str(cont) + ' - ' + i + '\n'
			if ('Required' or 'Subsystem' or 'Linker version') in i:
				self.metadata.append(i)
			elif 'Processed/created with' in i:
				try:
					self.metadata.append(i + ' ' + aux[cont+1])
					#self.metadata.append(aux[cont+1])
				except:
					pass
			cont+=1
			
		for i in self.metadata:
			print i + '\n'
			
		#x = raw_input('Enter your input:')
		
		
	def analiseDinamicaBib(self, caminho, PID):
		bibaux = []
		aux0 = caminho + 'volatility-2.2.exe -f C:\\Analise\\Dumps\\' + self.nome + '.raw --profile=Win7SP0x64 ldrmodules -p '
		aux = caminho + 'volatility-2.2.exe -f C:\\Analise\\Dumps\\' + self.nome + '.raw --profile=Win7SP0x64 ldrmodules -p ' + PID
		print 'AUX0 ==== ' + aux0 +'\n'
		print 'AUX ==== ' + aux + '\n'
		print 'PID ' + PID
		try:
			bibaux = subprocess.Popen(aux, shell=True, stdout=subprocess.PIPE).stdout.readlines()
			bibaux.pop(0)
		except:
			print '\n ERRO VOLATILITY \n!!'
			pass
		print 'TAMANHO DA LISTA ' + str(len(bibaux))
	# Parseando lista de processos para retirar as aspas
		
		for bib in bibaux:
			aux = bib.split(' ')
			size = len(aux)
			self.bib_d1.append(aux[size-1].strip('\n\r'))
		#Salva em pasta que vai pra Linux
		bibliotecas = open(pastaLinux + 'bibliotecas.txt', 'w')
		print 'BIBAUXXXX: \n'
		for bib in self.bib_d1:
			print bib
			bibliotecas.write(bib + '\n')
		
		bibliotecas.close()
		
	
	def defineCompactacao(self, caminho):
		pe = pefile.PE(self.artefato)
		signatures = peutils.SignatureDatabase(caminho)
		self.compactacao = signatures.match_all(pe, ep_only=True)
	
	def analisaArquivos(self, fs):
		#print '\ntff = ' + str(tf)
		aCriados = open(pastaLinux + 'arquivosCriados.txt','w')
		aModificados = open(pastaLinux + 'arquivosModificados.txt','w')
		aApagados = open(pastaLinux + 'arquivosApagados.txt','w')
		
		#Verifica se arquivo foi Criado , Modificado ou Apagado
		for action, name in fs:
			if ('winpmem' and 'C:\Analise\Dumps') not in name:
				if action == 1: #winnt.FILE_ACTION_ADDED:
					print 'Criado: ' + name
					self.arquivos_Criados.append(name)
				elif action == 2: # winnt.FILE_ACTION_REMOVED:
					print 'Removido: ' + name
					self.arquivos_Apagados.append(name)
				elif action == 3: #winnt.FILE_ACTION_MODIFIED:
					print 'Modificado: ' + name
					self.arquivos_Modificados.append(name)
		
		for file in self.arquivos_Apagados:
			if file in self.arquivos_Modificados:
				self.arquivos_Criados.append(file)
				self.arquivos_Apagados.remove(file)
				self.arquivos_Modificados.remove(file)
				
		#Passa para relatorio a ser enviado pro Linux		
		for i in self.arquivos_Criados:
			aCriados.write(i + '\n')
			
		for i in self.arquivos_Modificados:
			aModificados.write(i + '\n')
			
		for i in self.arquivos_Apagados:
			aApagados.write(i + '\n')
			
		aCriados.close()
		aModificados.close()
		aApagados.close()
			
			
	
	def analisaProcessos(self, lsInicial, lsFinal,cod):
		# Verifica se a lista de processos final eh igual a inicial
		# Se nao forem, registra processos diferentes em lsFinal na lista taskes
		listanproc = ['cmd.exe', 'tasklist.exe','winpmem-1.3.1.exe']
		for process in lsFinal:
			#print process
			if process in lsInicial:
				pass
			elif lsFinal[process] not in listanproc: # (str(process) != 'tasklist.exe'):
				if process not in self.taskes:
					#relatorio.write(lsFinal[process] + '\n')
					self.taskes[process] = lsFinal[process]
				#print ' DIFERENTE : ' + lsFinal[process] + ' ' + process + '\n'
				
		# Verifica se programa(artefato) ainda esta executando
		code = cod
		for proc in self.taskes:
			if proc in lsFinal:
				code = 1
				break
			else:
				code = 0
		return code
	
	def escreveProcessos(self):
		processos = open(pastaLinux + 'processos.txt', 'w')
		
		for i in self.taskes:
			processos.write(self.taskes[i] + '\n')
		
		processos.close()
		
	
	def modificacoes_registro(self, hklm, hkcu, hkcc, hkdd):
		if(hklm!=0):
			for i in hklm:
				if 'winpmem' not in i:
					self.registro.append(i)
		if(hkcu!=0):
			for i in hkcu:
				if 'winpmem' not in i:
					self.registro.append(i)
		#+ hkcu + hkcc + hkdd
		print 'REGISTRO : \n\n'
		arquivoRegistro = open(pastaLinux + 'registro.txt', 'w')
		
		for i in self.registro:
			arquivoRegistro.write(i + '\n')
		
		arquivoRegistro.close()
	
	
	
	def geraRelatorio(self, dinamica):
		relatorio = open(pastaRelatorio + self.hash.strip('\n\r') + '.txt', 'w')
		relatorio.write('Hash: ' + self.hash)    # a - Registra hash do arquivo no relatorio
		relatorio.write('Arquivo: ' + self.nome)
		relatorio.write('Tipo de arquivo" ' + self.tipo)
		relatorio.write('Bibliotecas em tempo de carregamento: \n')
		cont = 0
		for i in self.bib_e1:
			relatorio.write(str(cont) + ' ' + i + '\n') # d - Registra bibliotecas
			cont+=1
		
		relatorio.write('\n\nMETADATA: \n\n')
		for i in self.metadata:
			relatorio.write(i + '\n')
			
		if(str(self.compactacao) != 'None'):
			relatorio.write('Arquivo Compactado: \n' + str(self.compactacao))
			
		#if dinamica==0:
		#	relatorio.close()
		#	return 0
			
		relatorio.write('\n\n\n PROCESSOS CRIADOS: \n\n')
		for i in self.taskes:
			relatorio.write(self.taskes[i] + '\n')
	
		relatorio.write('\n\n\nSISTEMA DE ARQUIVOS:\n\n')
		relatorio.write('Arquivos Criados:\n\n')
	
		for c in self.arquivos_Criados:
			relatorio.write(c + '\n')
	
		relatorio.write('\n\nArquivos Modificados:\n\n')
	
		for m in self.arquivos_Modificados:
			relatorio.write(m + '\n')
		
		relatorio.write('\n\nArquivos Apagados:\n\n')
	
		for a in self.arquivos_Apagados:
			relatorio.write(a + '\n')
		
		relatorio.write('\n\n Run-time DLLs:\n')
		for i in self.bib_d1:
			relatorio.write(i + '\n')
		relatorio.close()
		
		shutil.copy(pastaRelatorio + self.hash.strip('\n\r') + '.txt', 'E:\\pastaLinux\\')
		return 1
		
	

		
	def geraRelatorioPDF(self, fontPresent, fontTitle, fontText, sizePresent, sizeTitle, sizeText, pasta):
		print '\n ENTROU NO RELATORIO PDF \n'
		fonts = ['Helvetica','Helvetica-Bold','Helvetica-BoldOblique']
		sizes = [10,12,20]
		# Legenda:
		# 0 = text
		# 1 = titulo
		# 2 = cabecalho
		
		narquivo = pasta + self.nome + '.pdf.'
		report = LibPDF(narquivo, 100, 760, sizes, fonts)

		tasklist = []
		for i in self.taskes:
			tasklist.append(self.taskes[i])
			
		#pdfText(text, textobject, fontsize=0, font='Helvetica', moveX=0, moveY=0)
		report.inicializaText()
		report.pdfText(self.nome,2,0,40)
		report.pdfText('MD5 hash: ',1)
		report.pdfText(self.hash,0)
		report.pdfText('Tipo de arquivo: ',1,0,10)
		report.pdfText(self.tipo,0)
		
		if(len(self.metadata)>0):
			report.pdfText('Metadata Colhida',1,0,20)
			report.pdfTextList(self.metadata,0)
			
		if(len(self.bib_e1)>0):
			report.pdfText('Bibliotecas Dinamicas encontradas na analise estatica: ',1,0,20)
			report.pdfTextList(self.bib_e1,0)
		else:
			report.pdfText('Arquivo Compactado: ',1,0,10)
			report.pdfText(str(self.compactacao),0)
			
		report.pdfText('Processos Criados',1,0,20)
		report.pdfTextList(tasklist, 0)
		
		if (len(self.arquivos_Criados)>0):
			report.pdfText('Arquivos Criados',1,0,40)
			report.pdfTextList(self.arquivos_Criados,0)
			
		if(len(self.arquivos_Modificados)>0):
			report.pdfText('Arquivos Modificados',1,0,20)
			report.pdfTextList(self.arquivos_Modificados,0)
		
		if(len(self.registro)>0):
			report.pdfText('Chaves de registro alteradas',1,0,20)
			report.pdfTextList(self.registro,0)
			
		if(len(self.bib_d1)>0):
			report.pdfText('Bibliotecas em tempo de execucao',1,0,20)
			report.pdfTextList(self.bib_d1,0)
		
		
		report.drawObject()
		report.saveDocument()
	
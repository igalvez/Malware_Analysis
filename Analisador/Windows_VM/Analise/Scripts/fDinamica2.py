import os
import subprocess
import sys
import time
import datetime
import signal
import win32api
import win32gui
import win32process
import win32con
import threading
import pywintypes
import win32event
import win32file
import win32Base
import libPDF
import reportlab
import winnt
import reset
import 	Queue
from classArtefato import ClassArtefato


###########################################	ANALISE DINAMICA ########################################################
#																												    #
#																													#
#									 1 - Processos Criados		(OK)											    #
#									 2 - Arquivos Criados, Modificados ou Apagados	(OK)	TESTAR				    #
#									 3 - Bibliotecas Chamadas	(OK)										        #
#									 4 - Alteracoes no Registro	 (OK) TESTAR									    #
#																													#
#																													#
#####################################################################################################################																													   #



#OBS : DESCOBRIR COMO "EXECUTAR" DLL
# RELATORIO COM REPORT LAB



fileChanges = Queue.Queue() # Fila para armazenar resultado de Threads
PASTA_RELATORIO_PDF = 'C:\\Analise\\RelatoriosPDF\\'
PASTA_ARTEFATOS = 'C:\\Analise\\Artefatos\\'
PASTA_FERRAMENTAS = 'C:\\Analise\\Ferramentas\\'
pastaLinux = 'C:\\Analise\\ResumoDinamica\\'
listanproc = ['cmd.exe', 'tasklist.exe'] # Processos que necessariamente vao estar na listagem
TEMPOMAX = 50
flag = 1


# THREAD PARA ANALISE DO SISTEMA DE ARQUIVOS


class memoryDump(threading.Thread):
	def __init__(self,name):
		self.hash = name
		self.bibaux = None
		threading.Thread.__init__(self)
	def run(self):
		p1 = PASTA_FERRAMENTAS + 'winpmem-1.3.1.exe C:\\Analise\\Dumps\\' + self.hash + '.raw'
		print p1 + '\n'
		subprocess.Popen(PASTA_FERRAMENTAS + 'winpmem-1.3.1.exe C:\\Analise\\Dumps\\' + self.hash + '.raw')
		

		
class checkForChanges(threading.Thread):
	# Thread que usa a funcao ReadDirectoryChangeW da API do Windows para verificar modificacoes em um diretorio
	def __init__(self, directory):
		self.path = directory
		self.buf = win32file.AllocateReadBuffer(8192)
		
		# Adquirindo um handle para o diretorio a se monitorar com a fucao Create File da API do windows
		
		self.hDir = win32file.CreateFile (
		 directory, 	# Diretorio
		 winnt.FILE_LIST_DIRECTORY, # Tipo de Acesso
		 win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE | win32con.FILE_SHARE_DELETE, # Acesso compartilhado
		 None,	# Atributos de Seguranca
		 win32con.OPEN_EXISTING, # Como abrir ( Nesse caso abre arquivos que ja existem)
		 win32con.FILE_FLAG_BACKUP_SEMANTICS | win32con.FILE_FLAG_OVERLAPPED, # Flags. Para modo assincrono -> FILE_FLAG_OVERLAPPED
		 None # Template File
		)
		threading.Thread.__init__(self)
	
	def run(self):
		overlapped = pywintypes.OVERLAPPED()
		overlapped.hEvent = win32event.CreateEvent(None, 0, 0, None)
		
		while flag==1:
			# Usando ReadDirectoryChangesW na forma assincrona(para nao bloquear o programa) para monitorar diretorio
			win32file.ReadDirectoryChangesW (
				self.hDir,		# Handle para diretorio
				self.buf,		# Buffer 
				True,			# Modo Recursivo?
				win32con.FILE_NOTIFY_CHANGE_FILE_NAME |    #Tipos de eventos a serem sinalizados
				win32con.FILE_NOTIFY_CHANGE_DIR_NAME |
				win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES |
				win32con.FILE_NOTIFY_CHANGE_SIZE |
				win32con.FILE_NOTIFY_CHANGE_LAST_WRITE |
				win32con.FILE_NOTIFY_CHANGE_SECURITY, 
				overlapped,		# Ponteiro para estrutura para utilizar modo assincrono
				None		# Completion Function
			)
			print 'wait1'
			# Captura evento ( Espera 1s)
			catchEvent = win32event.WaitForSingleObject(overlapped.hEvent, 1000)
			print 'after'
			
			# Verifica se algum evento foi capturado
			if catchEvent == win32event.WAIT_OBJECT_0:
				nbytes = win32file.GetOverlappedResult(self.hDir, overlapped, True)
				if nbytes:
					# Se algum evento foi capturado, armazenar informacoes na fila de resultados
					result = win32file.FILE_NOTIFY_INFORMATION(self.buf, nbytes)
					
					# AJUSTE: alterar pasta para exibir caminho inteiro a partir do drive C
					for i in result:
						tipo, arquivo = i
						pasta = self.path + arquivo
						resultFinal = tipo, pasta
						fileChanges.put(resultFinal)
				
		return		



		
def copy_registry(hklm, hkcu, hkcc, hkdd):
	a = subprocess.Popen('reg export \"HKLM\" ' + hklm, shell=True, stdout=subprocess.PIPE).stdout.read()
	a = subprocess.Popen('reg export \"HKCU\" ' + hkcu, shell=True, stdout=subprocess.PIPE).stdout.read()
	a = subprocess.Popen('reg export \"HKCC\" ' + hkcc, shell=True, stdout=subprocess.PIPE).stdout.read()
	a = subprocess.Popen('reg export \"HKDD\" ' + hkdd, shell=True, stdout=subprocess.PIPE).stdout.read()
	

def walker(arg, dirname, filenames):
	for i in filenames:
		m = os.path.join(dirname, i)
		arg[m] = datetime.datetime.fromtimestamp(int(abs(os.path.getmtime(m))))
		
def listaFinalTasks():
	lsFinal = {}
	lsFim = subprocess.Popen('tasklist /NH /FO CSV', shell=True, stdout=subprocess.PIPE).stdout.readlines()
	lsFim.pop(0)
	for reg in lsFim:
		procid = reg.split(',')[1].strip('\"')
		procname = reg.split(',')[0].strip('\"')
		lsFinal[procid] = procname
	return lsFinal		

def geraRelatorio(relatorio, taskes, aCriados, aModificados, aApagados):
	relatorio.write('\n\n\n PROCESSOS CRIADOS: \n\n')
	for i in taskes:
		relatorio.write(taskes[i] + '\n')
	
	relatorio.write('\n\n\nSISTEMA DE ARQUIVOS:\n\n')
	relatorio.write('Arquivos Criados:\n\n')
	
	for c in aCriados:
		relatorio.write(c + '\n')
	
	relatorio.write('\n\nArquivos Modificados:\n\n')
	
	for m in aModificados:
		relatorio.write(m + '\n')
		
	relatorio.write('\n\nArquivos Apagados:\n\n')
	
	for a in aApagados:
		relatorio.write(a + '\n')
		

def setFlag(valor):
	global flag
	flag = valor	


def detect_reg_change(r0, r1):
	result = subprocess.Popen('fc /u ' + r0 + ' ' + r1, shell=True, stdout=subprocess.PIPE).stdout.read()
	changes = []
	aux = []
	descarta = False
	
	if result[0]!='[':
		descarta = True
	
	p1 = result.split('[')
	
	for r in p1:
		aux.append(r.split(']'))
		
	print '\n LISTA S\n'
	
	for r in aux:
		changes.append(r[0])
	if descarta:
		changes.pop(0)
	#print '\n lalalala \n'
	#print str(result)
	print 'MUDANCAS'
	changes_sorted = sorted(set(changes))
	for i in changes:
		print i
	return changes

def exporta():
	itens = os.listdir(pastaLinux)
	
	for i in itens:
		try:
			shutil.copy(pastaLinux + i, 'E:\\pastaLinux')
			print '\nSUCESSO!\n'
		except:
			print '\nERRO NA EXPORTACAO\n'

			
def finaliza():
	exporta()
	flag = open('E:\\pastaLinux\\flag.txt','w')
	flag.write('FIM')
	flag.close()
	#os.system("shutdown")
	
	
def analiseDinamica(artefato, relatorio):

   # Nome dos arquivos das chaves de registro
	lm0 = 'C:\\Analise\\registro\\LM0.reg'    # HKLM antes
	lm1 = 'C:\\Analise\\registro\\LM1.reg'	  # HKLM depois
	hku0 = 'C:\\Analise\\registro\\HKU0.reg'  # HKCU antes
	hku1 = 'C:\\Analise\\registro\\HKU1.reg'  # HKCU depois
	cc0 = 'C:\\Analise\\registro\\CC0.reg'	  # HKCC antes
	cc1 = 'C:\\Analise\\registro\\CC1.reg'    # HKCC depois
	dd0 = 'C:\\Analise\\registro\\DD0.reg'	  # HKDD antes
	dd1 = 'C:\\Analise\\registro\\DD1.reg'    # HKDD depois
	
	#Copia registro antes de prog ser rodado
	copy_registry(lm0, hku0, cc0, dd0)
	
	lsInicial = {}
	print 'taskes INICIO ' + str(artefato.taskes)

	# 1 - Listando processos antes do programa ser rodado (Processos iniciais)
	lsI = subprocess.Popen('tasklist /NH /FO CSV', shell=True, stdout=subprocess.PIPE).stdout.readlines()
	print 'LISTA TYPE' + str(type(lsInicial))
	lsI.pop(0)
	# Parseando lista de processos para retirar as aspas
	for reg in lsI:
		aux = reg.split(',')
		procid = aux[1].strip('\"')
		procname= aux[0].strip('\"')
		lsInicial[procid] = procname

	del lsI

	# 2 - Roda o artefato
	
	setFlag(1)
	
	# Salva chaves de registro antes de rodar artefato
	#copy_registry(lm0, hku0, cc0, dd0)
	
	# Inicia threads para inspencionar diretorios
	dLocal = checkForChanges('C:\\Analise\\Artefatos\\')
	dWindows = checkForChanges('C:\\Windows\\')
	dPF = checkForChanges('C:\\Program Files\\')
	dPF86 = checkForChanges('C:\\Program Files (x86)\\')
	dC = checkForChanges('C:\\')
	dC.start()
	#dLocal.start()
	#dWindows.start()
	#dPF.start()
	#dPF86.start()
	
	
	# Executa artefato
	executa = win32Base.CreateNewProcess(artefato.artefato)
	code = 1
	if (executa==-1):
		code = 0
	
	artefato.pid = win32process.GetProcessId(executa[0])
	#print 'PID WIN32 ' + str(pid)
	
	mDump = memoryDump(artefato.nome)
	mDump.start()
	#raw_input(" ")
	
	print '\n\n Processos Criados: \n'
	#relatorio.write('\n\nProcessos criados: \n\n')
	
	inicio = time.time()
	sArquivosFinal = {}
	# Enquanto programa esta rodando
	while(code==1):
		# A cada loop lista processos 
		lsFinal = {}
		lsF = subprocess.Popen('tasklist /NH /FO CSV', shell=True, stdout=subprocess.PIPE).stdout.readlines()
		
		lsF.pop(0)
		for reg in lsF:
			procid = reg.split(',')[1].strip('\"')
			procname = reg.split(',')[0].strip('\"')
			lsFinal[procid] = procname
		
		# Armazena processos diferentes em lista de processos criados
		code = artefato.analisaProcessos(lsInicial, lsFinal, code)
		dt = time.time() - inicio
		print dt
		# Se tempo de execucao do programa ultrapassar 10 segundos matar todos os processos criados pelo programa
		if(dt>TEMPOMAX):
			code = 0
		if(code ==0):
			setFlag(0)  # Finaliza Threads de monitoramento de diretorios

			pid = win32process.GetProcessId(executa[0])
			print 'PID WIN32 ' + str(pid)
			
			# Verifica Handles do processo 
			windowHandles = []
			for task in artefato.taskes:
				print ' TASK ' + task
				windowHandles = windowHandles + win32Base.get_hwnds(long(task))
			print 'HANDLES ' + str(windowHandles)
			#if(len(windowHandles)==0):
			#	win32Base.killProcess(executa[0])
			
			# Tenta fechar processos
			for handwin in windowHandles:
				win32Base.sendCloseMessage(handwin)
				#win32Base.killProcess(handwin)
			
			lsFim = listaFinalTasks()
			print str(lsFim)
	
			# Matar processos que sobraram
			for task in artefato.taskes:
				if task in lsFim:
					hndl = win32Base.returnHandleForPid(long(task))
					win32Base.killProcess(hndl)

					
			
			fileList = [] 	# Lista para armazenar fila de arquivos alterados
			notEmpty = True
			
			# Coleta resultado da fila de diretorios alterados e passa pra uma lista
			while notEmpty:
				try:
					x = fileChanges.get(block=False)
					fileList.append(x)
				except Queue.Empty:
					notEmpty = False
					break
					
			# Remove entradas iguais
			fs = sorted(set(fileList))
			
			# 
			
			artefato.analisaArquivos(fs)
		
			#print mDump.bibaux
		del lsFinal
	mDump.join()
	
	# Salva chaves de registro apos encerrar artefato
	copy_registry(lm1, hku1, cc1, dd1)
	changes_hklm = detect_reg_change(lm0, lm1)
	changes_hkcu = detect_reg_change(hku0, hku1)
	#changes_hkcc = detect_reg_change(cc0, cc1)
	#changes_hkdd = detect_reg_change(dd0, dd1)
	artefato.escreveProcessos()
	artefato.modificacoes_registro(changes_hklm, changes_hkcu,0,0) #, changes_hkcu, changes_hkcc, changes_hkdd)
	artefato.analiseDinamicaBib(PASTA_FERRAMENTAS, str(artefato.pid))
	#os.path.walk('C:\\', walker, sArquivosFinal)
	
	#artefato.exporta()
	artefato.geraRelatorio(1)	
	finaliza()
	#artefato.geraRelatorioPDF('Helvetica-BoldOblique', 'Helvetica-Bold', 'Helvetica', 20, 12, 10, PASTA_RELATORIO_PDF)
	print 'MEMORY DUMP \n'
	print mDump.bibaux

